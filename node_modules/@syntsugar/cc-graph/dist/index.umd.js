(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('tslib')) :
    typeof define === 'function' && define.amd ? define(['exports', 'tslib'], factory) :
    (factory((global.ssGraph = {}),global.tslib));
}(this, (function (exports,tslib) { 'use strict';

    var GraphEdge = /** @class */ (function () {
        /**
         * Creates an instance of GraphEdge.
         * @param {GraphVertex} startVertex - 开始节点
         * @param {GraphVertex} endVertex - 结束节点
         * @param {number} [weight=0] - 边的权重
         * @memberof GraphEdge
         */
        function GraphEdge(startVertex, endVertex, weight) {
            if (weight === void 0) { weight = 0; }
            this.startVertex = startVertex;
            this.endVertex = endVertex;
            this.weight = weight;
        }
        /**
         * 获取 edge 的 key 值
         *
         * @returns {string}
         * @memberof GraphEdge
         */
        GraphEdge.prototype.getKey = function () {
            var startVertexKey = this.startVertex.getKey();
            var endVertexKey = this.endVertex.getKey();
            return startVertexKey + "_" + endVertexKey;
        };
        /**
         * 翻转这条边的指向
         *
         * @returns {GraphEdge}
         * @memberof GraphEdge
         */
        GraphEdge.prototype.reverse = function () {
            var tmp = this.startVertex;
            this.startVertex = this.endVertex;
            this.endVertex = tmp;
            return this;
        };
        /**
         * 复制边
         *
         * @returns {GraphEdge}
         * @memberof GraphEdge
         */
        GraphEdge.prototype.clone = function () {
            return new GraphEdge(this.startVertex, this.endVertex, this.weight);
        };
        /**
         * 重写 toString 方法
         *
         * @returns {string}
         * @memberof GraphEdge
         */
        GraphEdge.prototype.toString = function () {
            return this.getKey();
        };
        return GraphEdge;
    }());

    function invariant(check, message, scope) {
        if (scope === void 0) { scope = 'cc-graph'; }
        if (!check) {
            throw new Error((scope ? '[' + scope + ']' : '') + " Invariant failed: " + message);
        }
    }
    /**
     * 判断对象是否存在
     * @param {*} val - 待判断的对象
     * @param {bool} andString - 也要考虑字符串的 'undefined' 和 'null' 情况
     */
    function isExist(val, andString) {
        if (andString === void 0) { andString = true; }
        var result = typeof val !== 'undefined' && val !== null;
        if (andString) {
            return result && val !== 'undefined' && val !== 'null';
        }
        else {
            return result;
        }
    }

    var GraphVertex = /** @class */ (function () {
        /**
         * Creates an instance of GraphVertex.
         * @param {*} value - 节点值
         * @memberof GraphVertex
         */
        function GraphVertex(value) {
            invariant(isExist(value), 'Graph vertex must have a value');
            // Normally you would store string value like vertex name.
            // But generally it may be any object as well
            this.value = value;
            // 使用链表保存当前节点的边的集合
            this.edges = new Map();
        }
        /**
         * 将 edge 添加到当前节点的边链表中
         *
         * @param {GraphEdge} edge - edge 实例
         * @returns {GraphVertex}
         * @memberof GraphVertex
         */
        GraphVertex.prototype.addEdge = function (edge) {
            this.edges.set(edge.getKey(), edge);
            return this;
        };
        /**
         * 将 edge 从当前节点的边链表中删除
         *
         * @param {GraphEdge} edge  - edge 实例
         * @memberof GraphVertex
         */
        GraphVertex.prototype.deleteEdge = function (edge) {
            this.edges.delete(edge.getKey());
        };
        /**
         * 获取所有当前节点的相邻节点
         *
         * @returns {GraphVertex[]}
         * @memberof GraphVertex
         */
        GraphVertex.prototype.getNeighbors = function () {
            var _this = this;
            var edges = this.getEdges();
            var neighborsConverter = function (edge) {
                return edge.startVertex === _this ? edge.endVertex : edge.startVertex;
            };
            // Return either start or end vertex.
            // For undirected graphs it is possible that current vertex will be the end one.
            return edges.map(neighborsConverter);
        };
        /**
         * 获取所有的边
         *
         * @returns {GraphEdge[]}
         * @memberof GraphVertex
         */
        GraphVertex.prototype.getEdges = function () {
            return Array.from(this.edges.values());
        };
        /**
         * 获取当前节点的度
         *
         * @returns {number}
         * @memberof GraphVertex
         */
        GraphVertex.prototype.getDegree = function () {
            return this.getEdges().length;
        };
        /**
         * 判断某条边是否存在于当前节点上
         *
         * @param {GraphEdge} requiredEdge
         * @returns {boolean}
         * @memberof GraphVertex
         */
        GraphVertex.prototype.hasEdge = function (requiredEdge) {
            var edgeNode = this.getEdges().find(function (edge) { return edge === requiredEdge; });
            return !!edgeNode;
        };
        /**
         * 判断某个节点是否是和当前节点连接
         *
         * @param {GraphVertex} vertex
         * @returns {boolean}
         * @memberof GraphVertex
         */
        GraphVertex.prototype.hasNeighbor = function (vertex) {
            var vertexNode = this.getEdges().find(function (edge) {
                return edge.startVertex === vertex || edge.endVertex === vertex;
            });
            return !!vertexNode;
        };
        /**
         * 查找当前节点到指定节点的边，
         * 如果存在返回该边，否则返回 null
         *
         * @param {GraphVertex} vertex
         * @returns {*}
         * @memberof GraphVertex
         */
        GraphVertex.prototype.findEdge = function (vertex) {
            var edgeFinder = function (edge) {
                return edge.startVertex === vertex || edge.endVertex === vertex;
            };
            var edge = this.getEdges().find(edgeFinder);
            return edge ? edge : null;
        };
        /**
         * 返回当前节点 key 值
         *
         * @returns {*}
         * @memberof GraphVertex
         */
        GraphVertex.prototype.getKey = function () {
            return this.value;
        };
        /**
         * 删除当前节点所有的边
         *
         * @returns {GraphVertex}
         * @memberof GraphVertex
         */
        GraphVertex.prototype.deleteAllEdges = function () {
            var _this = this;
            this.getEdges().forEach(function (edge) { return _this.deleteEdge(edge); });
            return this;
        };
        /**
         * 重写 toString 方法
         *
         * @param {(value: any)=>string} [callback] - 支持自定义 toString 格式
         * @returns {string}
         * @memberof GraphVertex
         */
        GraphVertex.prototype.toString = function (callback) {
            return callback ? callback(this.value) : "" + this.value;
        };
        return GraphVertex;
    }());

    /**
     * enumeration of compare result, there is only three state
     *
     * @export
     * @enum {number}
     */
    var CompareResult;
    (function (CompareResult) {
        CompareResult[CompareResult["EQUAL"] = 0] = "EQUAL";
        CompareResult[CompareResult["GREATER"] = 1] = "GREATER";
        CompareResult[CompareResult["LESS"] = -1] = "LESS";
    })(CompareResult || (CompareResult = {}));
    /**
     * a class that describe how compares two object
     *
     * @export
     * @class Comparator
     */
    var Comparator = /** @class */ (function () {
        /**
         * Creates an instance of Comparator.
         * @param {compareFunction} compareFunction - function that implement compare operation
         * @memberof Comparator
         */
        function Comparator(compareFunction) {
            this.compare = compareFunction || Comparator.defaultCompareFunction;
        }
        /**
         * @param {(string|number)} a - compare target a
         * @param {(string|number)} b - compare target b
         * @returns {number}
         */
        Comparator.defaultCompareFunction = function (a, b) {
            if (a === b) {
                return CompareResult.EQUAL;
            }
            return a < b ? CompareResult.LESS : CompareResult.GREATER;
        };
        /**
         * compare if equal or not, a === b
         *
         * @param {*} a
         * @param {*} b
         * @returns {boolean}
         * @memberof Comparator
         */
        Comparator.prototype.equal = function (a, b) {
            return this.compare(a, b) === CompareResult.EQUAL;
        };
        /**
         * compare if smaller. a < b
         *
         * @param {*} a
         * @param {*} b
         * @returns {boolean}
         * @memberof Comparator
         */
        Comparator.prototype.lessThan = function (a, b) {
            return this.compare(a, b) === CompareResult.LESS;
        };
        /**
         * compare if greater. a > b
         *
         * @param {*} a
         * @param {*} b
         * @returns {boolean}
         * @memberof Comparator
         */
        Comparator.prototype.greaterThan = function (a, b) {
            return this.compare(a, b) === CompareResult.GREATER;
        };
        /**
         * compare if smaller or equal. a <= b
         *
         * @param {*} a
         * @param {*} b
         * @returns {boolean}
         * @memberof Comparator
         */
        Comparator.prototype.lessThanOrEqual = function (a, b) {
            return this.lessThan(a, b) || this.equal(a, b);
        };
        /**
         * compare if greater or equal. a >= b
         *
         * @param {*} a
         * @param {*} b
         * @returns {boolean}
         * @memberof Comparator
         */
        Comparator.prototype.greaterThanOrEqual = function (a, b) {
            return this.greaterThan(a, b) || this.equal(a, b);
        };
        /**
         * reverse the compare function
         *
         * @memberof Comparator
         */
        Comparator.prototype.reverse = function () {
            var compareOriginal = this.compare;
            this.compare = function (a, b) { return compareOriginal(b, a); };
        };
        return Comparator;
    }());

    var SinglyNode = /** @class */ (function () {
        function SinglyNode(val) {
            this.value = val;
            this.next = null;
        }
        return SinglyNode;
    }());
    var DoublyNode = /** @class */ (function () {
        function DoublyNode(val) {
            this.value = val;
            this.next = null;
            this.prev = null;
        }
        return DoublyNode;
    }());

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    var OBFUSCATED_ERROR = 'obfuse error occur';
    function invariant$1(check, message) {
        if (!check)
            throw new Error('[linked-list] ' + (message || OBFUSCATED_ERROR));
    }
    var INDEX_NOT_FOUND = -1;

    var List = /** @class */ (function () {
        function List() {
            var _this = this;
            var values = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                values[_i] = arguments[_i];
            }
            this._head = null;
            this._tail = null;
            this._length = 0;
            this.compare = new Comparator();
            if (values.length > 0) {
                values.forEach(function (value) {
                    _this.append(value);
                });
            }
        }
        Object.defineProperty(List.prototype, "head", {
            get: function () {
                return this._head ? this._head.value : void 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(List.prototype, "tail", {
            get: function () {
                return this._tail ? this._tail.value : void 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(List.prototype, "length", {
            get: function () {
                return this._length;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(List.prototype, "loopLength", {
            get: function () {
                var isLoop = false;
                var loopLength = 1;
                if (!this._head) {
                    return 0;
                }
                var p1 = this._head;
                var p2 = this._head;
                while (p2.next && p2.next.next) {
                    p2 = p2.next.next;
                    p1 = p1.next;
                    if (p1 === p2) {
                        isLoop = true;
                        break;
                    }
                }
                if (isLoop) {
                    p2 = p2.next;
                    while (p1 !== p2) {
                        loopLength++;
                        p2 = p2.next;
                    }
                    return loopLength;
                }
                else {
                    return 0;
                }
            },
            enumerable: true,
            configurable: true
        });
        List.prototype.getNode = function (position) {
            var length = this._length;
            // 1st use-case: invalid position
            invariant$1(length > 0 && position >= 0 && position < length, "[linked-list] index " + position + " out of scope of list, which length is " + length);
            var currentNode = this._head;
            var count = 0;
            // 2nd use-case: a valid position
            while (count < position) {
                currentNode = currentNode.next;
                count++;
            }
            return currentNode;
        };
        List.prototype.get = function (position) {
            var node = this.getNode(position);
            return node ? node.value : null;
        };
        /**
         * 根据指定条件返回待查找的链表节点
         *
         * @param {IFindConition<T>} { value, callback }
         * @returns
         * @memberof List
         */
        List.prototype.find = function (_a) {
            var value = _a.value, callback = _a.callback;
            if (!this._head) {
                return null;
            }
            var currentNode = this._head;
            while (currentNode) {
                // If callback is specified then try to find node by callback.
                if (callback && callback(currentNode.value)) {
                    return currentNode;
                }
                // If value is specified then try to compare by value..
                if (value !== undefined && this.compare.equal(currentNode.value, value)) {
                    return currentNode;
                }
                currentNode = currentNode.next;
            }
            return null;
        };
        List.prototype.indexOf = function (val) {
            if (!this._head) {
                return INDEX_NOT_FOUND;
            }
            var currentNode = this._head;
            var count = -1;
            // 多余 1 个节点的情况
            while (currentNode.next) {
                count++;
                if (this.compare.equal(currentNode.value, val)) {
                    return count;
                }
                currentNode = currentNode.next;
            }
            // 如果是末尾节点，需要额外处理
            if (currentNode === this._tail && this.compare.equal(currentNode.value, val)) {
                count += 1;
            }
            return count;
        };
        List.prototype.first = function (num) {
            invariant$1(num >= 0, "[linked-list] param 'num' (" + num + ") should not less than 0");
            var iter = this.iterator();
            var result = [];
            var n = Math.min(num, this.length);
            for (var i = 0; i < n; i++) {
                var val = iter.next();
                result.push(val.value);
            }
            return result;
        };
        List.prototype.toArray = function () {
            return __spread(this);
        };
        List.prototype.isEmpty = function () {
            return this._head === null;
        };
        List.prototype.iterator = function () {
            var currentNode;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        currentNode = this._head;
                        _a.label = 1;
                    case 1:
                        if (!currentNode) return [3 /*break*/, 3];
                        return [4 /*yield*/, currentNode.value];
                    case 2:
                        _a.sent();
                        currentNode = currentNode.next;
                        return [3 /*break*/, 1];
                    case 3: return [2 /*return*/];
                }
            });
        };
        List.prototype[Symbol.iterator] = function () {
            return this.iterator();
        };
        return List;
    }());

    var SinglyList = /** @class */ (function (_super) {
        __extends(SinglyList, _super);
        function SinglyList() {
            var values = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                values[_i] = arguments[_i];
            }
            return _super.apply(this, __spread(values)) || this;
        }
        // Adds the element at the end of the linked list
        SinglyList.prototype.append = function (val) {
            var node = new SinglyNode(val);
            if (!this._tail) {
                this._head = this._tail = node;
            }
            else {
                this._tail.next = node;
                this._tail = node;
            }
            this._length++;
            return true;
        };
        // Add the element at the beginning of the linked list
        SinglyList.prototype.prepend = function (val) {
            var node = new SinglyNode(val);
            if (!this._head) {
                this._head = this._tail = node;
            }
            else {
                node.next = this._head;
                this._head = node;
            }
            this._length++;
            return true;
        };
        // remove by value
        SinglyList.prototype.remove = function (val) {
            var currentNode = this._head;
            if (!currentNode) {
                return;
            }
            if (this.compare.equal(currentNode.value, val)) {
                // 这里需要注意，有两种情况：
                if (currentNode.next) {
                    // 链表多于 1 个元素
                    this._head = currentNode.next;
                    currentNode.next = null;
                }
                else {
                    // 链表只有 1 个元素
                    this._head = this._tail = null;
                }
                this._length--;
                return val;
            }
            else {
                var prevNode = currentNode;
                while (true) {
                    if (this.compare.equal(currentNode.value, val)) {
                        if (currentNode.next) {
                            prevNode.next = currentNode.next;
                        }
                        else {
                            // special case for last element
                            this._tail = prevNode;
                            this._tail.next = null;
                        }
                        currentNode.next = null;
                        this._length--;
                        return val;
                    }
                    else {
                        if (currentNode.next) {
                            prevNode = currentNode;
                            currentNode = currentNode.next;
                        }
                        else {
                            return;
                        }
                    }
                }
            }
        };
        SinglyList.prototype.removeHead = function () {
            var currentNode = this._head;
            // empty list
            if (!currentNode) {
                return;
            }
            // single item list
            if (!this._head.next) {
                this._head = null;
                this._tail = null;
                // full list
            }
            else {
                this._head = currentNode.next;
                currentNode.next = null;
            }
            this._length--;
            return currentNode.value;
        };
        SinglyList.prototype.removeTail = function () {
            var tailNode = this._tail;
            // empty list
            if (!tailNode) {
                return;
            }
            // single item list
            if (!this._head.next) {
                this._head = null;
                this._tail = null;
                // full list
            }
            else {
                // start traversal from head
                var currentNode = this._head;
                while (currentNode.next !== tailNode) {
                    currentNode = currentNode.next;
                }
                currentNode.next = null;
                this._tail = currentNode;
            }
            this._length--;
            return tailNode.value;
        };
        SinglyList.prototype.reverse = function () {
            if (!this._head) {
                return;
            }
            var currentNode = this._head;
            var prevNode = null;
            var nextNode;
            this._tail = this._head;
            while (currentNode !== null) {
                nextNode = currentNode.next;
                currentNode.next = prevNode;
                prevNode = currentNode;
                currentNode = nextNode;
            }
            this._head = prevNode;
        };
        SinglyList.prototype.clone = function () {
            var arrValue = this.toArray();
            return new (SinglyList.bind.apply(SinglyList, __spread([void 0], arrValue)))();
        };
        return SinglyList;
    }(List));
    var AbstractCircleSinglyList = /** @class */ (function (_super) {
        __extends(AbstractCircleSinglyList, _super);
        function AbstractCircleSinglyList() {
            var values = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                values[_i] = arguments[_i];
            }
            var _this = _super.apply(this, __spread(values)) || this;
            _this.cyclization();
            return _this;
        }
        AbstractCircleSinglyList.prototype.iterator = function () {
            var currentNode;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        currentNode = this._head;
                        _a.label = 1;
                    case 1:
                        if (!currentNode) return [3 /*break*/, 3];
                        return [4 /*yield*/, currentNode.value];
                    case 2:
                        _a.sent();
                        currentNode = currentNode.next;
                        // 如果下一个节点是 head，说明回到循环列表的头部了
                        if (currentNode === this._head) {
                            currentNode = null;
                        }
                        return [3 /*break*/, 1];
                    case 3: return [2 /*return*/];
                }
            });
        };
        AbstractCircleSinglyList.prototype.circleIterator = function () {
            var currentNode;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        currentNode = this._head;
                        _a.label = 1;
                    case 1:
                        if (!currentNode) return [3 /*break*/, 3];
                        return [4 /*yield*/, currentNode.value];
                    case 2:
                        _a.sent();
                        currentNode = currentNode.next;
                        return [3 /*break*/, 1];
                    case 3: return [2 /*return*/];
                }
            });
        };
        AbstractCircleSinglyList.prototype[Symbol.iterator] = function () {
            return this.iterator();
        };
        AbstractCircleSinglyList.prototype.mapToNormalListFn = function (name) {
            var params = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                params[_i - 1] = arguments[_i];
            }
            this.breakCircle();
            var result = _super.prototype[name].apply(this, params);
            this.cyclization();
            return result;
        };
        AbstractCircleSinglyList.prototype.getNode = function (position) {
            return this.mapToNormalListFn('getNode', position);
        };
        AbstractCircleSinglyList.prototype.append = function (val) {
            return this.mapToNormalListFn('append', val);
        };
        AbstractCircleSinglyList.prototype.prepend = function (val) {
            return this.mapToNormalListFn('prepend', val);
        };
        AbstractCircleSinglyList.prototype.find = function (condition) {
            return this.mapToNormalListFn('find', condition);
        };
        AbstractCircleSinglyList.prototype.indexOf = function (val) {
            return this.mapToNormalListFn('indexOf', val);
        };
        AbstractCircleSinglyList.prototype.remove = function (val) {
            return this.mapToNormalListFn('remove', val);
        };
        AbstractCircleSinglyList.prototype.removeHead = function () {
            return this.mapToNormalListFn('removeHead');
        };
        AbstractCircleSinglyList.prototype.removeTail = function () {
            return this.mapToNormalListFn('removeTail');
        };
        AbstractCircleSinglyList.prototype.first = function (num) {
            invariant$1(num >= 0, "[linked-list] param 'num' (" + num + ") should not less than 0");
            var iter = this.circleIterator();
            var result = [];
            for (var i = 0; i < num; i++) {
                var val = iter.next();
                result.push(val.value);
            }
            return result;
        };
        AbstractCircleSinglyList.prototype.toArray = function () {
            return this.mapToNormalListFn('toArray');
        };
        AbstractCircleSinglyList.prototype.reverse = function () {
            return this.mapToNormalListFn('reverse');
        };
        return AbstractCircleSinglyList;
    }(SinglyList));
    // 循环链表中的大部分方法，都可以转换成单向链表
    // 每次操作之前将列表断开，执行完后再结合
    var CircleSinglyList = /** @class */ (function (_super) {
        __extends(CircleSinglyList, _super);
        function CircleSinglyList() {
            var values = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                values[_i] = arguments[_i];
            }
            var _this = _super.apply(this, __spread(values)) || this;
            _this.cyclization();
            return _this;
        }
        CircleSinglyList.prototype.breakCircle = function () {
            if (this._tail && this._tail.next === this._head) {
                this._tail.next = null;
            }
        };
        CircleSinglyList.prototype.cyclization = function () {
            if (this._tail && this._tail.next === null) {
                this._tail.next = this._head;
            }
        };
        CircleSinglyList.prototype.clone = function () {
            var arrValue = this.toArray();
            return new (CircleSinglyList.bind.apply(CircleSinglyList, __spread([void 0], arrValue)))();
        };
        return CircleSinglyList;
    }(AbstractCircleSinglyList));

    var DoublyList = /** @class */ (function (_super) {
        __extends(DoublyList, _super);
        function DoublyList() {
            var values = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                values[_i] = arguments[_i];
            }
            return _super.apply(this, __spread(values)) || this;
        }
        // Adds the element at the end of the linked list
        DoublyList.prototype.append = function (val) {
            var node = new DoublyNode(val);
            if (!this._tail) {
                this._head = this._tail = node;
            }
            else {
                this._tail.next = node;
                node.prev = this._tail;
                this._tail = node;
            }
            this._length++;
            return true;
        };
        // Add the element at the beginning of the linked list
        DoublyList.prototype.prepend = function (val) {
            var node = new DoublyNode(val);
            if (!this._head) {
                this._head = this._tail = node;
            }
            else {
                node.next = this._head;
                this._head.prev = node;
                this._head = node;
            }
            this._length++;
            return true;
        };
        // remove by value
        DoublyList.prototype.remove = function (val) {
            var currentNode = this._head;
            if (!currentNode) {
                return;
            }
            // 当首个元素恰好是目标值的时候
            if (this.compare.equal(currentNode.value, val)) {
                // 这里需要注意，有两种情况：
                if (currentNode.next) {
                    // 链表多于 1 个元素
                    this._head = currentNode.next;
                    this._head.prev = null;
                    currentNode.next = currentNode.prev = null;
                }
                else {
                    // 链表只有 1 个元素
                    this._head = this._tail = null;
                }
                this._length--;
                return val;
            }
            else {
                while (true) {
                    if (this.compare.equal(currentNode.value, val)) {
                        if (currentNode.next) {
                            // special case for last element
                            currentNode.prev.next = currentNode.next;
                            currentNode.next.prev = currentNode.prev;
                            currentNode.next = currentNode.prev = null;
                        }
                        else {
                            currentNode.prev.next = null;
                            this._tail = currentNode.prev;
                            currentNode.next = currentNode.prev = null;
                        }
                        this._length--;
                        return currentNode.value;
                    }
                    else {
                        if (currentNode.next) {
                            currentNode = currentNode.next;
                        }
                        else {
                            return;
                        }
                    }
                }
            }
        };
        DoublyList.prototype.removeHead = function () {
            var currentNode = this._head;
            // empty list
            if (!currentNode) {
                return;
            }
            // single item list
            if (!this._head.next) {
                this._head = null;
                this._tail = null;
                // full list
            }
            else {
                currentNode.next.prev = null;
                this._head = currentNode.next;
                currentNode.next = null;
            }
            this._length--;
            return currentNode.value;
        };
        DoublyList.prototype.removeTail = function () {
            var tailNode = this._tail;
            // empty list
            if (!tailNode) {
                return;
            }
            // single item list
            if (!this._head.next) {
                this._head = null;
                this._tail = null;
                // full list
            }
            else {
                tailNode.prev.next = null;
                this._tail = tailNode.prev;
                tailNode.next = tailNode.prev = null;
            }
            this._length--;
            return tailNode.value;
        };
        DoublyList.prototype.reverse = function () {
            if (!this._head) {
                return;
            }
            var currentNode = this._head;
            var prevNode = null;
            var nextNode;
            this._tail = this._head;
            while (currentNode !== null) {
                nextNode = currentNode.next;
                currentNode.next = prevNode;
                currentNode.prev = nextNode;
                prevNode = currentNode;
                currentNode = nextNode;
            }
            this._head = prevNode;
        };
        DoublyList.prototype.clone = function () {
            var arrValue = this.toArray();
            return new (DoublyList.bind.apply(DoublyList, __spread([void 0], arrValue)))();
        };
        return DoublyList;
    }(List));
    var AbstractCircleDoublyList = /** @class */ (function (_super) {
        __extends(AbstractCircleDoublyList, _super);
        function AbstractCircleDoublyList() {
            var values = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                values[_i] = arguments[_i];
            }
            var _this = _super.apply(this, __spread(values)) || this;
            _this.cyclization();
            return _this;
        }
        AbstractCircleDoublyList.prototype.iterator = function () {
            var currentNode;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        currentNode = this._head;
                        _a.label = 1;
                    case 1:
                        if (!currentNode) return [3 /*break*/, 3];
                        return [4 /*yield*/, currentNode.value];
                    case 2:
                        _a.sent();
                        currentNode = currentNode.next;
                        // 如果下一个节点是 head，说明回到循环列表的头部了
                        if (currentNode === this._head) {
                            currentNode = null;
                        }
                        return [3 /*break*/, 1];
                    case 3: return [2 /*return*/];
                }
            });
        };
        AbstractCircleDoublyList.prototype.circleIterator = function () {
            var currentNode;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        currentNode = this._head;
                        _a.label = 1;
                    case 1:
                        if (!currentNode) return [3 /*break*/, 3];
                        return [4 /*yield*/, currentNode.value];
                    case 2:
                        _a.sent();
                        currentNode = currentNode.next;
                        return [3 /*break*/, 1];
                    case 3: return [2 /*return*/];
                }
            });
        };
        AbstractCircleDoublyList.prototype[Symbol.iterator] = function () {
            return this.iterator();
        };
        AbstractCircleDoublyList.prototype.mapToNormalListFn = function (name) {
            var params = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                params[_i - 1] = arguments[_i];
            }
            this.breakCircle();
            var result = _super.prototype[name].apply(this, params);
            this.cyclization();
            return result;
        };
        AbstractCircleDoublyList.prototype.getNode = function (position) {
            return this.mapToNormalListFn('getNode', position);
        };
        AbstractCircleDoublyList.prototype.append = function (val) {
            return this.mapToNormalListFn('append', val);
        };
        AbstractCircleDoublyList.prototype.prepend = function (val) {
            return this.mapToNormalListFn('prepend', val);
        };
        AbstractCircleDoublyList.prototype.find = function (condition) {
            return this.mapToNormalListFn('find', condition);
        };
        AbstractCircleDoublyList.prototype.indexOf = function (val) {
            return this.mapToNormalListFn('indexOf', val);
        };
        AbstractCircleDoublyList.prototype.remove = function (val) {
            return this.mapToNormalListFn('remove', val);
        };
        AbstractCircleDoublyList.prototype.removeHead = function () {
            return this.mapToNormalListFn('removeHead');
        };
        AbstractCircleDoublyList.prototype.removeTail = function () {
            return this.mapToNormalListFn('removeTail');
        };
        AbstractCircleDoublyList.prototype.first = function (num) {
            invariant$1(num >= 0, "[linked-list] param 'num' (" + num + ") should not less than 0");
            var iter = this.circleIterator();
            var result = [];
            for (var i = 0; i < num; i++) {
                var val = iter.next();
                result.push(val.value);
            }
            return result;
        };
        AbstractCircleDoublyList.prototype.toArray = function () {
            return this.mapToNormalListFn('toArray');
        };
        AbstractCircleDoublyList.prototype.reverse = function () {
            return this.mapToNormalListFn('reverse');
        };
        return AbstractCircleDoublyList;
    }(DoublyList));
    // 循环链表中的大部分方法，都可以转换成双向链表
    // 每次操作之前将列表断开，执行完后再结合
    var CircleDoublyList = /** @class */ (function (_super) {
        __extends(CircleDoublyList, _super);
        function CircleDoublyList() {
            var values = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                values[_i] = arguments[_i];
            }
            var _this = _super.apply(this, __spread(values)) || this;
            _this.cyclization();
            return _this;
        }
        CircleDoublyList.prototype.breakCircle = function () {
            if (this._tail && this._head && this._tail.next === this._head) {
                this._tail.next = null;
                this._head.prev = null;
            }
        };
        CircleDoublyList.prototype.cyclization = function () {
            if (this._head && this._tail && this._tail.next === null) {
                this._tail.next = this._head;
                this._head.prev = this._tail;
            }
        };
        CircleDoublyList.prototype.clone = function () {
            var arrValue = this.toArray();
            return new (CircleDoublyList.bind.apply(CircleDoublyList, __spread([void 0], arrValue)))();
        };
        return CircleDoublyList;
    }(AbstractCircleDoublyList));

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */

    function __read$1(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    function __spread$1() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read$1(arguments[i]));
        return ar;
    }

    var Queue = /** @class */ (function () {
        function Queue() {
            var values = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                values[_i] = arguments[_i];
            }
            // We're going to implement Queue based on LinkedList since the two
            // structures are quite similar. Namely, they both operate mostly on
            // the elements at the beginning and the end. Compare enqueue/dequeue
            // operations of Queue with append/deleteHead operations of LinkedList.
            this.queue = new (SinglyList.bind.apply(SinglyList, __spread$1([void 0], values)))();
        }
        Object.defineProperty(Queue.prototype, "length", {
            get: function () {
                return this.queue.length;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Queue.prototype, "peek", {
            /**
             * Read the element at the front of the queue without removing it.
             *
             * @returns {(T | void)}
             * @memberof Queue
             */
            get: function () {
                return this.queue.head;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * if is empty queue
         *
         * @returns {boolean}
         * @memberof Queue
         */
        Queue.prototype.isEmpty = function () {
            return this.queue.isEmpty();
        };
        /**
         * Add a new element to the end of the queue (the tail of the linked list).
         * This element will be processed after all elements ahead of it.
         *
         * @param {*} value
         * @returns {boolean}
         * @memberof Queue
         */
        Queue.prototype.enqueue = function (value) {
            return this.queue.append(value);
        };
        /**
         * Remove the element at the front of the queue (the head of the linked list).
         * If the queue is empty, return void.
         *
         * @returns {(T | void)}
         * @memberof Queue
         */
        Queue.prototype.dequeue = function () {
            var removedHead = this.queue.removeHead();
            return typeof removedHead !== 'undefined' ? removedHead : void 0;
        };
        /**
         * transform to array
         *
         * @returns {T[]}
         * @memberof Queue
         */
        Queue.prototype.toArray = function () {
            return this.queue.toArray();
        };
        return Queue;
    }());

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */

    function __read$2(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    function __spread$2() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read$2(arguments[i]));
        return ar;
    }

    var stack = /** @class */ (function () {
        function stack() {
            var values = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                values[_i] = arguments[_i];
            }
            // We're going to implement Stack based on LinkedList since these
            // structures are quite similar. Compare push/pop operations of the Stack
            // with append/deleteTail operations of LinkedList.
            this.stack = new (SinglyList.bind.apply(SinglyList, __spread$2([void 0], values)))();
        }
        Object.defineProperty(stack.prototype, "length", {
            get: function () {
                return this.stack.length;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(stack.prototype, "peek", {
            /**
             * Read the element at the front of the queue without removing it.
             *
             * @returns {(T | void)}
             * @memberof Queue
             */
            get: function () {
                return this.stack.tail;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * if is empty queue
         *
         * @returns {boolean}
         * @memberof Queue
         */
        stack.prototype.isEmpty = function () {
            return this.stack.isEmpty();
        };
        /**
         * Add a new element to the end of the queue (the tail of the linked list).
         * This element will be processed after all elements ahead of it.
         *
         * @param {*} value
         * @returns {boolean}
         * @memberof Queue
         */
        stack.prototype.push = function (value) {
            return this.stack.append(value);
        };
        /**
         * Remove the element at the front of the queue (the tail of the linked list).
         * If the queue is empty, return void.
         *
         * @returns {(T | void)}
         * @memberof Queue
         */
        stack.prototype.pop = function () {
            var removedTail = this.stack.removeTail();
            return typeof removedTail !== 'undefined' ? removedTail : void 0;
        };
        /**
         * Remove the element at the bottom of the queue (the head of the linked list).
         * If the queue is empty, return void.
         *
         * @returns {(T | void)}
         * @memberof Queue
         */
        stack.prototype.popBottom = function () {
            var removedHead = this.stack.removeHead();
            return typeof removedHead !== 'undefined' ? removedHead : void 0;
        };
        /**
         * transform to array
         *
         * @returns {T[]}
         * @memberof Queue
         */
        stack.prototype.toArray = function () {
            return this.stack.toArray();
        };
        return stack;
    }());

    /* ----------------------------------------------------
        util for find all path
    ----------------------------------------------------- */
    /**
     * 根据当前节点构建双栈
     *
     * @param {GraphVertex} vertex - 当前节点
     * @param {Stack<GraphVertex>} mainStack - 主栈
     * @param {Stack<GraphVertex[]>} neighborStack - 邻接节点栈
     * @param {Map<string, boolean>} visited - 已访问缓存
     */
    function buildDualStack(vertex, mainStack, neighborStack, visited) {
        if (vertex) {
            mainStack.push(vertex); // 将主节点入栈
            visited.set(vertex.getKey(), true); // 标记已被访问过
            // 获取 vertex 的邻接节点
            var neighbors = vertex
                .getNeighbors()
                .filter(function (v) { return !visited.get(v.getKey()); });
            neighborStack.push(neighbors);
        }
    }
    /**
     * 削减双栈（让双栈都减少一层）
     *
     * @param {Stack<GraphVertex>} mainStack
     * @param {Stack<GraphVertex[]>} neighborStack
     * @param {Map<string, boolean>} visited
     */
    function cutdownDualStack(mainStack, neighborStack, visited) {
        // 将目标元素从 mainStack 中弹出，
        var droppedMain = mainStack.pop();
        // 同时标记当前节点可以再次访问
        if (droppedMain) {
            visited.set(droppedMain.getKey(), false);
        }
        // 同时一并将 neighborStack 弹出元素
        neighborStack.pop();
    }
    // ==============
    var Graph = /** @class */ (function () {
        /**
         * Creates an instance of Graph.
         * @param {boolean} [isDirected=false] - 是否是有向图
         * @memberof Graph
         */
        function Graph(isDirected) {
            if (isDirected === void 0) { isDirected = false; }
            this.vertices = {};
            this.edges = {};
            this.isDirected = isDirected;
        }
        /**
         * 添加节点
         *
         * @param {GraphVertex} newVertex
         * @returns {Graph}
         * @memberof Graph
         */
        Graph.prototype.addVertex = function (newVertex) {
            this.vertices[newVertex.getKey()] = newVertex;
            return this;
        };
        /**
         * 根据 key 值返回指定节点
         *
         * @param {string} vertexKey
         * @returns {GraphVertex}
         * @memberof Graph
         */
        Graph.prototype.getVertexByKey = function (vertexKey) {
            return this.vertices[vertexKey];
        };
        /**
         * 返回指定节点的相邻节点
         *
         * @param {GraphVertex} vertex
         * @returns {GraphVertex[]}
         */
        Graph.prototype.getNeighbors = function (vertex) {
            return vertex.getNeighbors();
        };
        /**
         * 返回图中所有的节点
         *
         * @returns {GraphVertex[]}
         * @memberof Graph
         */
        Graph.prototype.getAllVertices = function () {
            return Object.values(this.vertices);
        };
        /**
         * 返回图中所有的边
         *
         * @returns {GraphEdge[]}
         * @memberof Graph
         */
        Graph.prototype.getAllEdges = function () {
            return Object.values(this.edges);
        };
        /**
         * 给图中添加边
         *
         * @param {GraphEdge} edge - 待添加的边
         * @param {boolean} [disableErrorWhenExist=false] - 是否关闭错误提示（当边已经存在图中的时候），默认是有错误提示
         * @returns {Graph}
         * @memberof Graph
         */
        Graph.prototype.addEdge = function (edge, disableErrorWhenExist) {
            if (disableErrorWhenExist === void 0) { disableErrorWhenExist = false; }
            // 判断边是否已经添加到图中
            if (this.edges[edge.getKey()]) {
                if (disableErrorWhenExist) {
                    return this;
                }
                else {
                    invariant(false, 'Edge has already been added before');
                }
            }
            // 首先找到开始和结束节点
            var startVertex = this.getVertexByKey(edge.startVertex.getKey());
            var endVertex = this.getVertexByKey(edge.endVertex.getKey());
            // 如果开始节点不存在图中，需要先添加
            if (!startVertex) {
                this.addVertex(edge.startVertex);
                startVertex = this.getVertexByKey(edge.startVertex.getKey()); // 注意：需要重新获取一次，不然 startVertex 不存在
            }
            // 如果结束节点不存在图中，需要先添加
            if (!endVertex) {
                this.addVertex(edge.endVertex);
                endVertex = this.getVertexByKey(edge.endVertex.getKey()); // 注意：需要重新获取一次，不然 endVertex 不存在
            }
            // 在图中添加这条边
            this.edges[edge.getKey()] = edge;
            // 根据是否是双向图
            if (this.isDirected) {
                // 如果是有向图，那么只用给 startVertex 添加此边
                startVertex.addEdge(edge);
            }
            else {
                // 否则就给开始、结束节点都添加该边
                startVertex.addEdge(edge);
                //   给结束节点添加边，需要 clone、然后再反向
                var clonedEdge = edge.clone();
                endVertex.addEdge(clonedEdge.reverse());
            }
            return this;
        };
        /**
         * 删除图中的某条边
         *
         * @param {GraphEdge} edge - 边的实例
         * @param {boolean} [disableErrorWhenExist=false] - 是否关闭错误提示（当图中不存在边时），默认是有错误提示
         * @returns {Graph}
         * @memberof Graph
         */
        Graph.prototype.deleteEdge = function (edge, disableErrorWhenExist) {
            if (disableErrorWhenExist === void 0) { disableErrorWhenExist = false; }
            // 判断边是否存在
            if (!this.edges[edge.getKey()]) {
                if (disableErrorWhenExist) {
                    return this;
                }
                else {
                    invariant(false, 'Edge not found in graph');
                }
            }
            // 先删除该边
            delete this.edges[edge.getKey()];
            // 同时找到该边所在开始节点和结束节点
            var startVertex = this.getVertexByKey(edge.startVertex.getKey());
            var endVertex = this.getVertexByKey(edge.endVertex.getKey());
            // 分别在节点上删除该边
            startVertex.deleteEdge(edge);
            endVertex.deleteEdge(edge);
            return this;
        };
        /**
         * 查找开始节点和结束节点之间的那条边
         *
         * @param {GraphVertex} startVertex - 开始节点
         * @param {GraphVertex} endVertex - 结束节点
         * @returns {(GraphEdge | null)}
         * @memberof Graph
         */
        Graph.prototype.findEdge = function (startVertex, endVertex) {
            // 首先判断开始节点是否在图中
            var vertex = this.getVertexByKey(startVertex.getKey());
            if (!vertex) {
                return null;
            }
            // 然后通过开始节点 - 结束节点对应的边的实例
            return vertex.findEdge(endVertex);
        };
        /**
         * 返回图中所有边的权重之和
         *
         * @returns {number}
         * @memberof Graph
         */
        Graph.prototype.getWeight = function () {
            return this.getAllEdges().reduce(function (weight, graphEdge) {
                return weight + graphEdge.weight;
            }, 0);
        };
        /**
         * 让图中所有的边都方向
         *
         * @returns {Graph}
         * @memberof Graph
         */
        Graph.prototype.reverse = function () {
            var _this = this;
            // 遍历所有的边
            this.getAllEdges().forEach(function (edge) {
                // 先将边从图中删除（反向操作之前一定要删除边，不然数据会存在不一致性 -  key 没有反向，而 this.edges[key] 反向了 ）
                _this.deleteEdge(edge);
                // 然后将边进行反向操作
                edge.reverse();
                // 再将边添加回图中
                _this.addEdge(edge);
            });
            return this;
        };
        /**
         * 返回“节点 - 索引”映射表
         *
         * @returns {{ [key: string]: number }} - 映射表对象
         * @memberof Graph
         */
        Graph.prototype.getVerticesIndices = function () {
            var verticesIndices = {};
            this.getAllVertices().forEach(function (vertex, index) {
                verticesIndices[vertex.getKey()] = index;
            });
            return verticesIndices;
        };
        /**
         * 生成邻接矩阵
         *
         * @returns {number[][]}
         * @memberof Graph
         */
        Graph.prototype.getAdjacencyMatrix = function () {
            var _this = this;
            // 获取所有的节点列表
            var vertices = this.getAllVertices();
            // 获取节点索引映射表
            var verticesIndices = this.getVerticesIndices();
            // 初始化邻接矩阵，赋值 `Infinity` 表示两点之间不可达
            // 邻接矩阵是 N x N 大小的
            var adjacencyMatrix = Array(vertices.length)
                .fill(null)
                .map(function () {
                return Array(vertices.length).fill(Infinity);
            });
            // 给每一列赋值
            vertices.forEach(function (vertex, vertexIndex) {
                vertex.getNeighbors().forEach(function (neighbor) {
                    var neighborIndex = verticesIndices[neighbor.getKey()];
                    var edge = _this.findEdge(vertex, neighbor);
                    if (!!edge) {
                        adjacencyMatrix[vertexIndex][neighborIndex] = edge.weight;
                    }
                });
            });
            return adjacencyMatrix;
        };
        /**
         * 重写 toString 方法，仅仅是打印出所有节点的列表
         * @return {string}
         */
        Graph.prototype.toString = function () {
            return Object.keys(this.vertices).toString();
        };
        /**
         * Breadth-first search (BFS)
         *
         * @param {GraphVertex} first - first node to start the bfs
         * @memberof Graph
         */
        Graph.prototype.bfs = function (first) {
            var visited, nodeQueue, node;
            return tslib.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        visited = new Map();
                        nodeQueue = new Queue();
                        // 将第一个节点入栈
                        nodeQueue.enqueue(first);
                        _a.label = 1;
                    case 1:
                        if (!!nodeQueue.isEmpty()) return [3 /*break*/, 4];
                        node = nodeQueue.dequeue();
                        if (!(node && !visited.has(node.getKey()))) return [3 /*break*/, 3];
                        return [4 /*yield*/, node];
                    case 2:
                        _a.sent();
                        visited.set(node.getKey(), node);
                        // 挨个将相邻节点放到队列中去
                        node
                            .getNeighbors()
                            .forEach(function (neighbor) { return nodeQueue.enqueue(neighbor); });
                        _a.label = 3;
                    case 3: return [3 /*break*/, 1];
                    case 4: return [2 /*return*/];
                }
            });
        };
        /**
         * Depth-first search (DFS)
         *
         * @param {GraphVertex} first - first node to start the dfs
         * @memberof Graph
         */
        Graph.prototype.dfs = function (first) {
            var visited, nodeStack, node;
            return tslib.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        visited = new Map();
                        nodeStack = new stack();
                        nodeStack.push(first);
                        _a.label = 1;
                    case 1:
                        if (!!nodeStack.isEmpty()) return [3 /*break*/, 4];
                        node = nodeStack.pop();
                        if (!(node && !visited.has(node.getKey()))) return [3 /*break*/, 3];
                        return [4 /*yield*/, node];
                    case 2:
                        _a.sent();
                        visited.set(node.getKey(), node);
                        // 挨个将相邻节点放到 stack 中去
                        node
                            .getNeighbors()
                            .forEach(function (neighbor) { return nodeStack.push(neighbor); });
                        _a.label = 3;
                    case 3: return [3 /*break*/, 1];
                    case 4: return [2 /*return*/];
                }
            });
        };
        Graph.prototype.findAllPath = function (source, target) {
            var path, visited, mainStack, neighborStack, curNeighbors, nextVertex, peekNode;
            return tslib.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        path = [];
                        if (!(source === target)) return [3 /*break*/, 2];
                        path.push(source);
                        return [4 /*yield*/, path];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                    case 2:
                        visited = new Map();
                        mainStack = new stack();
                        neighborStack = new stack();
                        buildDualStack(source, mainStack, neighborStack, visited);
                        _a.label = 3;
                    case 3:
                        if (!!mainStack.isEmpty()) return [3 /*break*/, 6];
                        curNeighbors = neighborStack.pop();
                        // 如果邻接栈有元素可用，就将其堆放在 mainStack 上
                        if (curNeighbors && curNeighbors.length) {
                            nextVertex = curNeighbors.shift();
                            neighborStack.push(curNeighbors); // 将其压栈压回去
                            // 如果存在下一个节点
                            if (nextVertex) {
                                buildDualStack(nextVertex, mainStack, neighborStack, visited);
                            }
                        }
                        else {
                            neighborStack.push(curNeighbors); // 将其压栈压回去，不然接下来的 cutdownDualStack 会导致 pop 两次
                            // 如果邻接节点是空数组，也削减一层
                            cutdownDualStack(mainStack, neighborStack, visited);
                            return [3 /*break*/, 3]; // 继续下一次循环
                        }
                        peekNode = mainStack.peek;
                        if (!(peekNode === target)) return [3 /*break*/, 5];
                        return [4 /*yield*/, mainStack.toArray()];
                    case 4:
                        _a.sent();
                        // 削减一层
                        cutdownDualStack(mainStack, neighborStack, visited);
                        _a.label = 5;
                    case 5: return [3 /*break*/, 3];
                    case 6: return [2 /*return*/];
                }
            });
        };
        return Graph;
    }());

    exports.GraphEdge = GraphEdge;
    exports.GraphVertex = GraphVertex;
    exports.Graph = Graph;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

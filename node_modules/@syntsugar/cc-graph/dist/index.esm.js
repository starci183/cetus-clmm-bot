import { __generator } from 'tslib';
import Queue from 'ss-queue';
import Stack from 'ss-stack';

var GraphEdge = /** @class */ (function () {
    /**
     * Creates an instance of GraphEdge.
     * @param {GraphVertex} startVertex - 开始节点
     * @param {GraphVertex} endVertex - 结束节点
     * @param {number} [weight=0] - 边的权重
     * @memberof GraphEdge
     */
    function GraphEdge(startVertex, endVertex, weight) {
        if (weight === void 0) { weight = 0; }
        this.startVertex = startVertex;
        this.endVertex = endVertex;
        this.weight = weight;
    }
    /**
     * 获取 edge 的 key 值
     *
     * @returns {string}
     * @memberof GraphEdge
     */
    GraphEdge.prototype.getKey = function () {
        var startVertexKey = this.startVertex.getKey();
        var endVertexKey = this.endVertex.getKey();
        return startVertexKey + "_" + endVertexKey;
    };
    /**
     * 翻转这条边的指向
     *
     * @returns {GraphEdge}
     * @memberof GraphEdge
     */
    GraphEdge.prototype.reverse = function () {
        var tmp = this.startVertex;
        this.startVertex = this.endVertex;
        this.endVertex = tmp;
        return this;
    };
    /**
     * 复制边
     *
     * @returns {GraphEdge}
     * @memberof GraphEdge
     */
    GraphEdge.prototype.clone = function () {
        return new GraphEdge(this.startVertex, this.endVertex, this.weight);
    };
    /**
     * 重写 toString 方法
     *
     * @returns {string}
     * @memberof GraphEdge
     */
    GraphEdge.prototype.toString = function () {
        return this.getKey();
    };
    return GraphEdge;
}());

function invariant(check, message, scope) {
    if (scope === void 0) { scope = 'cc-graph'; }
    if (!check) {
        throw new Error((scope ? '[' + scope + ']' : '') + " Invariant failed: " + message);
    }
}
/**
 * 判断对象是否存在
 * @param {*} val - 待判断的对象
 * @param {bool} andString - 也要考虑字符串的 'undefined' 和 'null' 情况
 */
function isExist(val, andString) {
    if (andString === void 0) { andString = true; }
    var result = typeof val !== 'undefined' && val !== null;
    if (andString) {
        return result && val !== 'undefined' && val !== 'null';
    }
    else {
        return result;
    }
}

var GraphVertex = /** @class */ (function () {
    /**
     * Creates an instance of GraphVertex.
     * @param {*} value - 节点值
     * @memberof GraphVertex
     */
    function GraphVertex(value) {
        invariant(isExist(value), 'Graph vertex must have a value');
        // Normally you would store string value like vertex name.
        // But generally it may be any object as well
        this.value = value;
        // 使用链表保存当前节点的边的集合
        this.edges = new Map();
    }
    /**
     * 将 edge 添加到当前节点的边链表中
     *
     * @param {GraphEdge} edge - edge 实例
     * @returns {GraphVertex}
     * @memberof GraphVertex
     */
    GraphVertex.prototype.addEdge = function (edge) {
        this.edges.set(edge.getKey(), edge);
        return this;
    };
    /**
     * 将 edge 从当前节点的边链表中删除
     *
     * @param {GraphEdge} edge  - edge 实例
     * @memberof GraphVertex
     */
    GraphVertex.prototype.deleteEdge = function (edge) {
        this.edges.delete(edge.getKey());
    };
    /**
     * 获取所有当前节点的相邻节点
     *
     * @returns {GraphVertex[]}
     * @memberof GraphVertex
     */
    GraphVertex.prototype.getNeighbors = function () {
        var _this = this;
        var edges = this.getEdges();
        var neighborsConverter = function (edge) {
            return edge.startVertex === _this ? edge.endVertex : edge.startVertex;
        };
        // Return either start or end vertex.
        // For undirected graphs it is possible that current vertex will be the end one.
        return edges.map(neighborsConverter);
    };
    /**
     * 获取所有的边
     *
     * @returns {GraphEdge[]}
     * @memberof GraphVertex
     */
    GraphVertex.prototype.getEdges = function () {
        return Array.from(this.edges.values());
    };
    /**
     * 获取当前节点的度
     *
     * @returns {number}
     * @memberof GraphVertex
     */
    GraphVertex.prototype.getDegree = function () {
        return this.getEdges().length;
    };
    /**
     * 判断某条边是否存在于当前节点上
     *
     * @param {GraphEdge} requiredEdge
     * @returns {boolean}
     * @memberof GraphVertex
     */
    GraphVertex.prototype.hasEdge = function (requiredEdge) {
        var edgeNode = this.getEdges().find(function (edge) { return edge === requiredEdge; });
        return !!edgeNode;
    };
    /**
     * 判断某个节点是否是和当前节点连接
     *
     * @param {GraphVertex} vertex
     * @returns {boolean}
     * @memberof GraphVertex
     */
    GraphVertex.prototype.hasNeighbor = function (vertex) {
        var vertexNode = this.getEdges().find(function (edge) {
            return edge.startVertex === vertex || edge.endVertex === vertex;
        });
        return !!vertexNode;
    };
    /**
     * 查找当前节点到指定节点的边，
     * 如果存在返回该边，否则返回 null
     *
     * @param {GraphVertex} vertex
     * @returns {*}
     * @memberof GraphVertex
     */
    GraphVertex.prototype.findEdge = function (vertex) {
        var edgeFinder = function (edge) {
            return edge.startVertex === vertex || edge.endVertex === vertex;
        };
        var edge = this.getEdges().find(edgeFinder);
        return edge ? edge : null;
    };
    /**
     * 返回当前节点 key 值
     *
     * @returns {*}
     * @memberof GraphVertex
     */
    GraphVertex.prototype.getKey = function () {
        return this.value;
    };
    /**
     * 删除当前节点所有的边
     *
     * @returns {GraphVertex}
     * @memberof GraphVertex
     */
    GraphVertex.prototype.deleteAllEdges = function () {
        var _this = this;
        this.getEdges().forEach(function (edge) { return _this.deleteEdge(edge); });
        return this;
    };
    /**
     * 重写 toString 方法
     *
     * @param {(value: any)=>string} [callback] - 支持自定义 toString 格式
     * @returns {string}
     * @memberof GraphVertex
     */
    GraphVertex.prototype.toString = function (callback) {
        return callback ? callback(this.value) : "" + this.value;
    };
    return GraphVertex;
}());

/* ----------------------------------------------------
    util for find all path
----------------------------------------------------- */
/**
 * 根据当前节点构建双栈
 *
 * @param {GraphVertex} vertex - 当前节点
 * @param {Stack<GraphVertex>} mainStack - 主栈
 * @param {Stack<GraphVertex[]>} neighborStack - 邻接节点栈
 * @param {Map<string, boolean>} visited - 已访问缓存
 */
function buildDualStack(vertex, mainStack, neighborStack, visited) {
    if (vertex) {
        mainStack.push(vertex); // 将主节点入栈
        visited.set(vertex.getKey(), true); // 标记已被访问过
        // 获取 vertex 的邻接节点
        var neighbors = vertex
            .getNeighbors()
            .filter(function (v) { return !visited.get(v.getKey()); });
        neighborStack.push(neighbors);
    }
}
/**
 * 削减双栈（让双栈都减少一层）
 *
 * @param {Stack<GraphVertex>} mainStack
 * @param {Stack<GraphVertex[]>} neighborStack
 * @param {Map<string, boolean>} visited
 */
function cutdownDualStack(mainStack, neighborStack, visited) {
    // 将目标元素从 mainStack 中弹出，
    var droppedMain = mainStack.pop();
    // 同时标记当前节点可以再次访问
    if (droppedMain) {
        visited.set(droppedMain.getKey(), false);
    }
    // 同时一并将 neighborStack 弹出元素
    neighborStack.pop();
}
// ==============
var Graph = /** @class */ (function () {
    /**
     * Creates an instance of Graph.
     * @param {boolean} [isDirected=false] - 是否是有向图
     * @memberof Graph
     */
    function Graph(isDirected) {
        if (isDirected === void 0) { isDirected = false; }
        this.vertices = {};
        this.edges = {};
        this.isDirected = isDirected;
    }
    /**
     * 添加节点
     *
     * @param {GraphVertex} newVertex
     * @returns {Graph}
     * @memberof Graph
     */
    Graph.prototype.addVertex = function (newVertex) {
        this.vertices[newVertex.getKey()] = newVertex;
        return this;
    };
    /**
     * 根据 key 值返回指定节点
     *
     * @param {string} vertexKey
     * @returns {GraphVertex}
     * @memberof Graph
     */
    Graph.prototype.getVertexByKey = function (vertexKey) {
        return this.vertices[vertexKey];
    };
    /**
     * 返回指定节点的相邻节点
     *
     * @param {GraphVertex} vertex
     * @returns {GraphVertex[]}
     */
    Graph.prototype.getNeighbors = function (vertex) {
        return vertex.getNeighbors();
    };
    /**
     * 返回图中所有的节点
     *
     * @returns {GraphVertex[]}
     * @memberof Graph
     */
    Graph.prototype.getAllVertices = function () {
        return Object.values(this.vertices);
    };
    /**
     * 返回图中所有的边
     *
     * @returns {GraphEdge[]}
     * @memberof Graph
     */
    Graph.prototype.getAllEdges = function () {
        return Object.values(this.edges);
    };
    /**
     * 给图中添加边
     *
     * @param {GraphEdge} edge - 待添加的边
     * @param {boolean} [disableErrorWhenExist=false] - 是否关闭错误提示（当边已经存在图中的时候），默认是有错误提示
     * @returns {Graph}
     * @memberof Graph
     */
    Graph.prototype.addEdge = function (edge, disableErrorWhenExist) {
        if (disableErrorWhenExist === void 0) { disableErrorWhenExist = false; }
        // 判断边是否已经添加到图中
        if (this.edges[edge.getKey()]) {
            if (disableErrorWhenExist) {
                return this;
            }
            else {
                invariant(false, 'Edge has already been added before');
            }
        }
        // 首先找到开始和结束节点
        var startVertex = this.getVertexByKey(edge.startVertex.getKey());
        var endVertex = this.getVertexByKey(edge.endVertex.getKey());
        // 如果开始节点不存在图中，需要先添加
        if (!startVertex) {
            this.addVertex(edge.startVertex);
            startVertex = this.getVertexByKey(edge.startVertex.getKey()); // 注意：需要重新获取一次，不然 startVertex 不存在
        }
        // 如果结束节点不存在图中，需要先添加
        if (!endVertex) {
            this.addVertex(edge.endVertex);
            endVertex = this.getVertexByKey(edge.endVertex.getKey()); // 注意：需要重新获取一次，不然 endVertex 不存在
        }
        // 在图中添加这条边
        this.edges[edge.getKey()] = edge;
        // 根据是否是双向图
        if (this.isDirected) {
            // 如果是有向图，那么只用给 startVertex 添加此边
            startVertex.addEdge(edge);
        }
        else {
            // 否则就给开始、结束节点都添加该边
            startVertex.addEdge(edge);
            //   给结束节点添加边，需要 clone、然后再反向
            var clonedEdge = edge.clone();
            endVertex.addEdge(clonedEdge.reverse());
        }
        return this;
    };
    /**
     * 删除图中的某条边
     *
     * @param {GraphEdge} edge - 边的实例
     * @param {boolean} [disableErrorWhenExist=false] - 是否关闭错误提示（当图中不存在边时），默认是有错误提示
     * @returns {Graph}
     * @memberof Graph
     */
    Graph.prototype.deleteEdge = function (edge, disableErrorWhenExist) {
        if (disableErrorWhenExist === void 0) { disableErrorWhenExist = false; }
        // 判断边是否存在
        if (!this.edges[edge.getKey()]) {
            if (disableErrorWhenExist) {
                return this;
            }
            else {
                invariant(false, 'Edge not found in graph');
            }
        }
        // 先删除该边
        delete this.edges[edge.getKey()];
        // 同时找到该边所在开始节点和结束节点
        var startVertex = this.getVertexByKey(edge.startVertex.getKey());
        var endVertex = this.getVertexByKey(edge.endVertex.getKey());
        // 分别在节点上删除该边
        startVertex.deleteEdge(edge);
        endVertex.deleteEdge(edge);
        return this;
    };
    /**
     * 查找开始节点和结束节点之间的那条边
     *
     * @param {GraphVertex} startVertex - 开始节点
     * @param {GraphVertex} endVertex - 结束节点
     * @returns {(GraphEdge | null)}
     * @memberof Graph
     */
    Graph.prototype.findEdge = function (startVertex, endVertex) {
        // 首先判断开始节点是否在图中
        var vertex = this.getVertexByKey(startVertex.getKey());
        if (!vertex) {
            return null;
        }
        // 然后通过开始节点 - 结束节点对应的边的实例
        return vertex.findEdge(endVertex);
    };
    /**
     * 返回图中所有边的权重之和
     *
     * @returns {number}
     * @memberof Graph
     */
    Graph.prototype.getWeight = function () {
        return this.getAllEdges().reduce(function (weight, graphEdge) {
            return weight + graphEdge.weight;
        }, 0);
    };
    /**
     * 让图中所有的边都方向
     *
     * @returns {Graph}
     * @memberof Graph
     */
    Graph.prototype.reverse = function () {
        var _this = this;
        // 遍历所有的边
        this.getAllEdges().forEach(function (edge) {
            // 先将边从图中删除（反向操作之前一定要删除边，不然数据会存在不一致性 -  key 没有反向，而 this.edges[key] 反向了 ）
            _this.deleteEdge(edge);
            // 然后将边进行反向操作
            edge.reverse();
            // 再将边添加回图中
            _this.addEdge(edge);
        });
        return this;
    };
    /**
     * 返回“节点 - 索引”映射表
     *
     * @returns {{ [key: string]: number }} - 映射表对象
     * @memberof Graph
     */
    Graph.prototype.getVerticesIndices = function () {
        var verticesIndices = {};
        this.getAllVertices().forEach(function (vertex, index) {
            verticesIndices[vertex.getKey()] = index;
        });
        return verticesIndices;
    };
    /**
     * 生成邻接矩阵
     *
     * @returns {number[][]}
     * @memberof Graph
     */
    Graph.prototype.getAdjacencyMatrix = function () {
        var _this = this;
        // 获取所有的节点列表
        var vertices = this.getAllVertices();
        // 获取节点索引映射表
        var verticesIndices = this.getVerticesIndices();
        // 初始化邻接矩阵，赋值 `Infinity` 表示两点之间不可达
        // 邻接矩阵是 N x N 大小的
        var adjacencyMatrix = Array(vertices.length)
            .fill(null)
            .map(function () {
            return Array(vertices.length).fill(Infinity);
        });
        // 给每一列赋值
        vertices.forEach(function (vertex, vertexIndex) {
            vertex.getNeighbors().forEach(function (neighbor) {
                var neighborIndex = verticesIndices[neighbor.getKey()];
                var edge = _this.findEdge(vertex, neighbor);
                if (!!edge) {
                    adjacencyMatrix[vertexIndex][neighborIndex] = edge.weight;
                }
            });
        });
        return adjacencyMatrix;
    };
    /**
     * 重写 toString 方法，仅仅是打印出所有节点的列表
     * @return {string}
     */
    Graph.prototype.toString = function () {
        return Object.keys(this.vertices).toString();
    };
    /**
     * Breadth-first search (BFS)
     *
     * @param {GraphVertex} first - first node to start the bfs
     * @memberof Graph
     */
    Graph.prototype.bfs = function (first) {
        var visited, nodeQueue, node;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    visited = new Map();
                    nodeQueue = new Queue();
                    // 将第一个节点入栈
                    nodeQueue.enqueue(first);
                    _a.label = 1;
                case 1:
                    if (!!nodeQueue.isEmpty()) return [3 /*break*/, 4];
                    node = nodeQueue.dequeue();
                    if (!(node && !visited.has(node.getKey()))) return [3 /*break*/, 3];
                    return [4 /*yield*/, node];
                case 2:
                    _a.sent();
                    visited.set(node.getKey(), node);
                    // 挨个将相邻节点放到队列中去
                    node
                        .getNeighbors()
                        .forEach(function (neighbor) { return nodeQueue.enqueue(neighbor); });
                    _a.label = 3;
                case 3: return [3 /*break*/, 1];
                case 4: return [2 /*return*/];
            }
        });
    };
    /**
     * Depth-first search (DFS)
     *
     * @param {GraphVertex} first - first node to start the dfs
     * @memberof Graph
     */
    Graph.prototype.dfs = function (first) {
        var visited, nodeStack, node;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    visited = new Map();
                    nodeStack = new Stack();
                    nodeStack.push(first);
                    _a.label = 1;
                case 1:
                    if (!!nodeStack.isEmpty()) return [3 /*break*/, 4];
                    node = nodeStack.pop();
                    if (!(node && !visited.has(node.getKey()))) return [3 /*break*/, 3];
                    return [4 /*yield*/, node];
                case 2:
                    _a.sent();
                    visited.set(node.getKey(), node);
                    // 挨个将相邻节点放到 stack 中去
                    node
                        .getNeighbors()
                        .forEach(function (neighbor) { return nodeStack.push(neighbor); });
                    _a.label = 3;
                case 3: return [3 /*break*/, 1];
                case 4: return [2 /*return*/];
            }
        });
    };
    Graph.prototype.findAllPath = function (source, target) {
        var path, visited, mainStack, neighborStack, curNeighbors, nextVertex, peekNode;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    path = [];
                    if (!(source === target)) return [3 /*break*/, 2];
                    path.push(source);
                    return [4 /*yield*/, path];
                case 1:
                    _a.sent();
                    return [2 /*return*/];
                case 2:
                    visited = new Map();
                    mainStack = new Stack();
                    neighborStack = new Stack();
                    buildDualStack(source, mainStack, neighborStack, visited);
                    _a.label = 3;
                case 3:
                    if (!!mainStack.isEmpty()) return [3 /*break*/, 6];
                    curNeighbors = neighborStack.pop();
                    // 如果邻接栈有元素可用，就将其堆放在 mainStack 上
                    if (curNeighbors && curNeighbors.length) {
                        nextVertex = curNeighbors.shift();
                        neighborStack.push(curNeighbors); // 将其压栈压回去
                        // 如果存在下一个节点
                        if (nextVertex) {
                            buildDualStack(nextVertex, mainStack, neighborStack, visited);
                        }
                    }
                    else {
                        neighborStack.push(curNeighbors); // 将其压栈压回去，不然接下来的 cutdownDualStack 会导致 pop 两次
                        // 如果邻接节点是空数组，也削减一层
                        cutdownDualStack(mainStack, neighborStack, visited);
                        return [3 /*break*/, 3]; // 继续下一次循环
                    }
                    peekNode = mainStack.peek;
                    if (!(peekNode === target)) return [3 /*break*/, 5];
                    return [4 /*yield*/, mainStack.toArray()];
                case 4:
                    _a.sent();
                    // 削减一层
                    cutdownDualStack(mainStack, neighborStack, visited);
                    _a.label = 5;
                case 5: return [3 /*break*/, 3];
                case 6: return [2 /*return*/];
            }
        });
    };
    return Graph;
}());

export { GraphEdge, GraphVertex, Graph };
